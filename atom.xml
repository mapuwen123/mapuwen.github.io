<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marvin&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-27T01:01:56.688Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Puwen Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android-事件分发</title>
    <link href="http://yoursite.com/2019/06/26/Android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>http://yoursite.com/2019/06/26/Android-事件分发/</id>
    <published>2019-06-26T07:23:58.000Z</published>
    <updated>2019-06-27T01:01:56.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-事件分发"><a href="#Android-事件分发" class="headerlink" title="Android-事件分发"></a>Android-事件分发</h2><h3 id="一、基础认识"><a href="#一、基础认识" class="headerlink" title="一、基础认识"></a>一、基础认识</h3><ul><li><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4></li></ul><blockquote><p>当用户触摸屏幕时（<code>View</code> 或 <code>ViewGroup</code>派生的控件），将产生点击事件（<code>Touch</code>事件）</p><p><code>Touch</code>事件的相关细节（发生触摸的位置、时间等）被封装成<code>MotionEvent</code>对象</p></blockquote><ul><li><h4 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h4><table><thead><tr><th>事件类型</th><th>具体动作</th></tr></thead><tbody><tr><td>MotionEvent.ACTION_DOWN</td><td>按下View（所有事件的开始）</td></tr><tr><td>MotionEvent.ACTION_UP</td><td>抬起View（与DOWN对应）</td></tr><tr><td>MotionEvent.ACTION_MOVE</td><td>滑动View</td></tr><tr><td>MotionEvent.ACTION_CANCEL</td><td>结束事件（非人为原因）</td></tr></tbody></table></li><li><h4 id="事件列"><a href="#事件列" class="headerlink" title="事件列"></a>事件列</h4><p>  从手指接触屏幕 至 手指离开屏幕，这个过程产生的一系列事件</p><blockquote><p>注：一般情况下，事件列都是以DOWN事件开始、UP事件结束，中间有无数的MOVE事件，如下图：<br><img src="/img/20190626-0/20190626-0-0.png" alt></p></blockquote></li><li><h4 id="事件分发的顺序"><a href="#事件分发的顺序" class="headerlink" title="事件分发的顺序"></a>事件分发的顺序</h4><p>  即 事件传递的顺序：Activity -&gt; ViewGroup -&gt; View<br><img src="/img/20190626-0/20190626-0-1.png" alt></p></li><li><h4 id="事件分发过程由哪些方法协作完成"><a href="#事件分发过程由哪些方法协作完成" class="headerlink" title="事件分发过程由哪些方法协作完成"></a>事件分发过程由哪些方法协作完成</h4><p>  dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()<br><img src="/img/20190626-0/20190626-0-2.png" alt></p></li></ul><h3 id="二、Activity的事件分发"><a href="#二、Activity的事件分发" class="headerlink" title="二、Activity的事件分发"></a>二、Activity的事件分发</h3><pre><code>当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发</code></pre><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：Activity.dispatchTouchEvent（）</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一般事件列开始都是DOWN事件 = 按下事件，故此处基本是true</span></span><br><span class="line">            <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"></span><br><span class="line">                onUserInteraction();</span><br><span class="line">                <span class="comment">// -&gt;&gt;分析1</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// -&gt;&gt;分析2</span></span><br><span class="line">            <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 若getWindow().superDispatchTouchEvent(ev)的返回true</span></span><br><span class="line">                <span class="comment">// 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 &amp; 事件传递过程结束</span></span><br><span class="line">                <span class="comment">// 否则：继续往下调用Activity.onTouchEvent</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// -&gt;&gt;分析4</span></span><br><span class="line">            <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：onUserInteraction()</span></span><br><span class="line"><span class="comment">  * 作用：实现屏保功能</span></span><br><span class="line"><span class="comment">  * 注：</span></span><br><span class="line"><span class="comment">  *    a. 该方法为空方法</span></span><br><span class="line"><span class="comment">  *    b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserInteraction</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 回到最初的调用原处</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：getWindow().superDispatchTouchEvent(ev)</span></span><br><span class="line"><span class="comment">  * 说明：</span></span><br><span class="line"><span class="comment">  *     a. getWindow() = 获取Window类的对象</span></span><br><span class="line"><span class="comment">  *     b. Window类是抽象类，其唯一实现类 = PhoneWindow类；即此处的Window类对象 = PhoneWindow类对象</span></span><br><span class="line"><span class="comment">  *     c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">        <span class="comment">// mDecor = 顶层View（DecorView）的实例对象</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析3：mDecor.superDispatchTouchEvent(event)</span></span><br><span class="line"><span class="comment">  * 定义：属于顶层View（DecorView）</span></span><br><span class="line"><span class="comment">  * 说明：</span></span><br><span class="line"><span class="comment">  *     a. DecorView类是PhoneWindow类的一个内部类</span></span><br><span class="line"><span class="comment">  *     b. DecorView继承自FrameLayout，是所有界面的父类</span></span><br><span class="line"><span class="comment">  *     c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        <span class="comment">// 调用父类的方法 = ViewGroup的dispatchTouchEvent()</span></span><br><span class="line">        <span class="comment">// 即 将事件传递到ViewGroup去处理，详细请看ViewGroup的事件分发机制</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回到最初的调用原处</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析4：Activity.onTouchEvent（）</span></span><br><span class="line"><span class="comment">  * 定义：属于顶层View（DecorView）</span></span><br><span class="line"><span class="comment">  * 说明：</span></span><br><span class="line"><span class="comment">  *     a. DecorView类是PhoneWindow类的一个内部类</span></span><br><span class="line"><span class="comment">  *     b. DecorView继承自FrameLayout，是所有界面的父类</span></span><br><span class="line"><span class="comment">  *     c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当一个点击事件未被Activity下任何一个View接收 / 处理时</span></span><br><span class="line">        <span class="comment">// 应用场景：处理发生在Window边界外的触摸事件</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析5</span></span><br><span class="line">        <span class="keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            finish();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 即 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析5：mWindow.shouldCloseOnTouch(this, event)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldCloseOnTouch</span><span class="params">(Context context, MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等</span></span><br><span class="line">    <span class="keyword">if</span> (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">            &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 返回true：说明事件在边界外，即 消费事件</span></span><br><span class="line">    <span class="comment">// 返回false：未消费（默认）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回到分析4调用原处</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>当一个点击事件发生时，从Activity的事件分发开始（Activity.dispatchTouchEvent()）</code></pre><p><img src="/img/20190626-0/20190626-0-3.png" alt></p><ul><li>方法总结<br><img src="/img/20190626-0/20190626-0-4.png" alt></li></ul><h3 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android-事件分发&quot;&gt;&lt;a href=&quot;#Android-事件分发&quot; class=&quot;headerlink&quot; title=&quot;Android-事件分发&quot;&gt;&lt;/a&gt;Android-事件分发&lt;/h2&gt;&lt;h3 id=&quot;一、基础认识&quot;&gt;&lt;a href=&quot;#一、基础认识&quot;
      
    
    </summary>
    
    
      <category term="Androd" scheme="http://yoursite.com/tags/Androd/"/>
    
      <category term="View" scheme="http://yoursite.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Java集合-HashMap</title>
    <link href="http://yoursite.com/2019/06/25/Java%E9%9B%86%E5%90%88-HashMap/"/>
    <id>http://yoursite.com/2019/06/25/Java集合-HashMap/</id>
    <published>2019-06-25T13:07:59.000Z</published>
    <updated>2019-06-25T13:17:11.185Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java集合-LinkedList</title>
    <link href="http://yoursite.com/2019/06/19/Java%E9%9B%86%E5%90%88-LinkedList/"/>
    <id>http://yoursite.com/2019/06/19/Java集合-LinkedList/</id>
    <published>2019-06-19T05:53:38.000Z</published>
    <updated>2019-06-25T13:16:33.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。</span><br><span class="line"></span><br><span class="line">按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。</span><br><span class="line"></span><br><span class="line">插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add()，addFirst()，removeLast()或用iterator()上的remove()能省掉指针的移动。</span><br><span class="line"></span><br><span class="line">LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"语文: 1"</span>);</span><br><span class="line">list.add(<span class="string">"数学: 2"</span>);</span><br><span class="line">list.add(<span class="string">"英语: 3"</span>);</span><br></pre></td></tr></table></figure><p><img src="/img/20190619-0/20190619-0-0.png" alt="LinkedList img"></p><h2 id="二、set和get函数"><a href="#二、set和get函数" class="headerlink" title="二、set和get函数"></a>二、set和get函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数都调用了<code>node</code>函数，该函数会以O(n/2)的性能去获取一个节点，具体实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java集合-ArrayList</title>
    <link href="http://yoursite.com/2019/06/16/Java%E9%9B%86%E5%90%88-ArrayList/"/>
    <id>http://yoursite.com/2019/06/16/Java集合-ArrayList/</id>
    <published>2019-06-15T16:41:47.000Z</published>
    <updated>2019-06-19T07:57:03.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><pre><code>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"语文: 99"</span>);</span><br><span class="line">list.add(<span class="string">"数学: 98"</span>);</span><br><span class="line">list.add(<span class="string">"英语: 100"</span>);</span><br><span class="line">list.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在执行这四条语句时，是这么变化的：</p><p><img src="/img/20190616-0/20190616-0-0.png" alt="Arraylist Img"></p><h2 id="二、add函数"><a href="#二、add函数" class="headerlink" title="二、add函数"></a>二、add函数</h2><p>当我们在ArrayList中增加元素的时候，会使用<code>add</code>函数。他会将元素放到末尾。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 数组自动扩容</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他的实现其实最核心的内容就是<code>ensureCapacityInternal</code>。这个函数就是<strong>自动扩容机制的核心</strong>。他的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩展为原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩为1.5倍还不满足需求，直接扩为需求值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们<code>add</code>10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示：</p><p><img src="/img/20190616-0/20190616-0-1.png" alt="Arraylist add Img"></p><h2 id="三、set和get函数"><a href="#三、set和get函数" class="headerlink" title="三、set和get函数"></a>三、set和get函数</h2><p>先做index检查，然后执行赋值或访问操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//index检查，超出数组长度抛出IndexOutOfBoundsException异常</span></span><br><span class="line">    rangeCheck(index); </span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、remove函数"><a href="#四、remove函数" class="headerlink" title="四、remove函数"></a>四、remove函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//index检查，超出数组长度抛出IndexOutOfBoundsException异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 把后面的往前移</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 把最后的置null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-集合</title>
    <link href="http://yoursite.com/2019/06/12/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/06/12/Java基础-集合/</id>
    <published>2019-06-11T21:13:03.000Z</published>
    <updated>2019-06-26T15:31:24.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java集合简介"><a href="#一、Java集合简介" class="headerlink" title="一、Java集合简介"></a>一、Java集合简介</h2><ul><li><p>Set：无序、不可重复</p></li><li><p>List：有序、重复的</p></li><li><p>Map：具有映射关系</p></li><li><p>Queue：队列集合实现</p></li></ul><h3 id="1-集合与数组的区别"><a href="#1-集合与数组的区别" class="headerlink" title="1. 集合与数组的区别"></a>1. 集合与数组的区别</h3><ul><li><p>数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。</p></li><li><p>数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。</p></li></ul><h3 id="2-Java集合类之间的继承关系"><a href="#2-Java集合类之间的继承关系" class="headerlink" title="2. Java集合类之间的继承关系"></a>2. Java集合类之间的继承关系</h3><ul><li><p>Java的集合类主要由两个接口派生而出:</p><ul><li><p>Collection</p><p><img src="/img/20190612-0/3985563-e7febf364d8d8235-1.png" alt="Collection Img"></p></li><li><p>Map (key-value具有映射关系的集合)</p><p><img src="/img/20190612-0/3985563-06052107849a7603-2.png" alt="Map Img"></p></li></ul></li></ul><h2 id="二、Collection接口"><a href="#二、Collection接口" class="headerlink" title="二、Collection接口"></a>二、Collection接口</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><pre><code>Collection接口是Set,Queue,List的父接口。</code></pre><h4 id="1-1-接口中定义的方法"><a href="#1-1-接口中定义的方法" class="headerlink" title="1.1. 接口中定义的方法"></a>1.1. 接口中定义的方法</h4><p><img src="/img/20190612-0/3985563-414332ffe4733274-3.png" alt="Collection Function Img"></p><p><strong><em>注：重点看iterator()方法</em></strong></p><h4 id="1-2-使用Iterator遍历集合元素"><a href="#1-2-使用Iterator遍历集合元素" class="headerlink" title="1.2. 使用Iterator遍历集合元素"></a>1.2. 使用Iterator遍历集合元素</h4><pre><code>Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。 Iterator接口中主要定义了2个方法：</code></pre><p><img src="/img/20190612-0/3985563-63737a2d81713a47-4.png" alt="Iterator Img"></p><p>使用迭代器遍历集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建集合</span></span><br><span class="line">    Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        collection.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得集合的迭代器</span></span><br><span class="line">    Iterator iterator = collection.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123; <span class="comment">//判断是否存在下一个元素</span></span><br><span class="line">        <span class="comment">//取出元素并打印</span></span><br><span class="line">        System.out.println(iterator.next() + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>当使用Iterator对集合元素进行迭代时，把集合元素的值传给了迭代变量，<strong>基本数据类型</strong>传递的是<strong>值</strong>。<strong>引用类型</strong>传递的仅仅是对象的<strong>引用变量</strong>。</p><h3 id="2-Set集合"><a href="#2-Set集合" class="headerlink" title="2. Set集合"></a>2. Set集合</h3><pre><code>Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。</code></pre><h3 id="3-List集合"><a href="#3-List集合" class="headerlink" title="3. List集合"></a>3. List集合</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1. 简介"></a>3.1. 简介</h4><pre><code>List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。</code></pre><h4 id="3-2-接口中定义的方法"><a href="#3-2-接口中定义的方法" class="headerlink" title="3.2. 接口中定义的方法"></a>3.2. 接口中定义的方法</h4><ul><li><p><strong>void add(int index, Object element):</strong> 在列表的指定位置插入指定元素（可选操作）。</p></li><li><p><strong>boolean addAll(int index, Collection&lt;? extends E&gt; c) :</strong> 将集合c 中的所有元素都插入到列表中的指定位置index处。</p></li><li><p><strong>Object get(index):</strong>  返回列表中指定位置的元素。</p></li><li><p><strong>int indexOf(Object o):</strong> 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。</p></li><li><p><strong>int lastIndexOf(Object o):</strong> 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。</p></li><li><p><strong>Object remove(int index):</strong> 移除列表中指定位置的元素。</p></li><li><p><strong>Object set(int index, Object element):</strong> 用指定元素替换列表中指定位置的元素。</p></li><li><p><strong>List subList(int fromIndex, int toIndex):</strong> 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集。</p></li><li><p><strong>Object[] toArray():</strong> 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。</p></li><li><p><strong>void replaceAll(UnaryOperator operator):</strong> 根据operator指定的计算规则重新设置List集合的所有元素。</p></li><li><p><strong>void sort(Comparator c):</strong> 根据Comparator参数对List集合的元素排序。</p><p><strong>注：</strong>replaceAll和sort为Java8 新增方法：</p></li></ul><h3 id="4-Queue集合"><a href="#4-Queue集合" class="headerlink" title="4. Queue集合"></a>4. Queue集合</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1. 简介"></a>4.1. 简介</h4><pre><code>Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</code></pre><h4 id="4-2-接口中定义的方法"><a href="#4-2-接口中定义的方法" class="headerlink" title="4.2. 接口中定义的方法"></a>4.2. 接口中定义的方法</h4><p><img src="/img/20190612-0/3985563-0505554930ca982e-5.png" alt="Queue Function Img"></p><h2 id="三、Map集合"><a href="#三、Map集合" class="headerlink" title="三、Map集合"></a>三、Map集合</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><pre><code>Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。如下图所描述，key和value之间存在单向一对一关系，即通过指定的key,总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value。</code></pre><p><img src="/img/20190612-0/3985563-51f6c5278df941fe-6.png" alt="Map Img"></p><h3 id="2-Map集合与Set集合、List集合的关系"><a href="#2-Map集合与Set集合、List集合的关系" class="headerlink" title="2. Map集合与Set集合、List集合的关系"></a>2. Map集合与Set集合、List集合的关系</h3><ul><li><p><strong>与Set集合的关系</strong></p><p>如果 把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用户返回Map里所有key组成的Set集合。</p></li><li><p><strong>与List集合的关系</strong></p><p>如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。</p></li></ul><h3 id="3-接口中定义的方法"><a href="#3-接口中定义的方法" class="headerlink" title="3. 接口中定义的方法"></a>3. 接口中定义的方法</h3><p><img src="/img/20190612-0/3985563-d2494516e1d68a6d-7.png" alt="Map Function Img"></p><p>Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法：</p><p><img src="/img/20190612-0/3985563-ecedd1880af9d40a-8.png" alt="Entry Function Img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Java集合简介&quot;&gt;&lt;a href=&quot;#一、Java集合简介&quot; class=&quot;headerlink&quot; title=&quot;一、Java集合简介&quot;&gt;&lt;/a&gt;一、Java集合简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Set：无序、不可重复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
