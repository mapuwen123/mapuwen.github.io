<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Activity启动流程（二）]]></title>
    <url>%2F2019%2F06%2F30%2FActivity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Activity启动流程接上一篇 ActivityManagerService 中调用 startActivityAsUser() 方法，得到 ActivityStarter 对象并调用 execute() 方法， ActivityStarter 内部调用 startActivityMayWait() ，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511// 目录：com/android/server/am/ActivityStarter.javaprivate int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup, PendingIntentRecord originatingPendingIntent) &#123; // Refuse possible leaked file descriptors // intent不能传递文件句柄否则抛出异常 if (intent != null &amp;&amp; intent.hasFileDescriptors()) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; // mSupervisor是一个ActivityStackSupervisor对象，ActivityStackSupervisor是一个Activity栈的管理类 // 这里通过ActivityStackSupervisor的getActivityMetricsLogger()方法取得一个ActivityMetricsLogger对象 // notifyActivityLaunching()方法通知ActivityMetricsLogger Activity开始启动更新开始启动时间 注1 mSupervisor.getActivityMetricsLogger().notifyActivityLaunching(); /** * 省略部分不重要代码 */ // 解析Intent数据 ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, 0 /* matchFlags */, computeResolveFilterUid( callingUid, realCallingUid, mRequest.filterCallingUid)); if (rInfo == null) &#123; UserInfo userInfo = mSupervisor.getUserInfo(userId); if (userInfo != null &amp;&amp; userInfo.isManagedProfile()) &#123; // Special case for managed profiles, if attempting to launch non-cryto aware // app in a locked managed profile from an unlocked parent allow it to resolve // as user will be sent via confirm credentials to unlock the profile. UserManager userManager = UserManager.get(mService.mContext); boolean profileLockedAndParentUnlockingOrUnlocked = false; long token = Binder.clearCallingIdentity(); try &#123; UserInfo parent = userManager.getProfileParent(userId); profileLockedAndParentUnlockingOrUnlocked = (parent != null) &amp;&amp; userManager.isUserUnlockingOrUnlocked(parent.id) &amp;&amp; !userManager.isUserUnlockingOrUnlocked(userId); &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; if (profileLockedAndParentUnlockingOrUnlocked) &#123; rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE, computeResolveFilterUid( callingUid, realCallingUid, mRequest.filterCallingUid)); &#125; &#125; &#125; // Collect information about the target of the Intent. // ActivityInfo用于保存从AndroidManifest.xml解析的数据 // 隐式调用时用来匹配Activity ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); synchronized (mService) &#123; final ActivityStack stack = mSupervisor.mFocusedStack; stack.mConfigWillChange = globalConfig != null &amp;&amp; mService.getGlobalConfiguration().diff(globalConfig) != 0; if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, "Starting activity when config will change = " + stack.mConfigWillChange); final long origId = Binder.clearCallingIdentity(); if (aInfo != null &amp;&amp; (aInfo.applicationInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0 &amp;&amp; mService.mHasHeavyWeightFeature) &#123; // This may be a heavy-weight process! Check to see if we already // have another, different heavy-weight process running. // 判断是否已经存在不同于目标进程的重量级进程，如果存在则会重新赋值intent if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123; final ProcessRecord heavy = mService.mHeavyWeightProcess; if (heavy != null &amp;&amp; (heavy.info.uid != aInfo.applicationInfo.uid || !heavy.processName.equals(aInfo.processName))) &#123; int appCallingUid = callingUid; if (caller != null) &#123; ProcessRecord callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; appCallingUid = callerApp.info.uid; &#125; else &#123; Slog.w(TAG, "Unable to find app for caller " + caller + " (pid=" + callingPid + ") when starting: " + intent.toString()); SafeActivityOptions.abort(options); return ActivityManager.START_PERMISSION_DENIED; &#125; &#125; IIntentSender target = mService.getIntentSenderLocked( ActivityManager.INTENT_SENDER_ACTIVITY, "android", appCallingUid, userId, null, null, 0, new Intent[] &#123; intent &#125;, new String[] &#123; resolvedType &#125;, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT, null); Intent newIntent = new Intent(); if (requestCode &gt;= 0) &#123; // Caller is requesting a result. newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true); &#125; newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT, new IntentSender(target)); if (heavy.activities.size() &gt; 0) &#123; ActivityRecord hist = heavy.activities.get(0); newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP, hist.packageName); newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK, hist.getTask().taskId); &#125; newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP, aInfo.packageName); newIntent.setFlags(intent.getFlags()); newIntent.setClassName("android", HeavyWeightSwitcherActivity.class.getName()); intent = newIntent; resolvedType = null; caller = null; callingUid = Binder.getCallingUid(); callingPid = Binder.getCallingPid(); componentSpecified = true; rInfo = mSupervisor.resolveIntent(intent, null /*resolvedType*/, userId, 0 /* matchFlags */, computeResolveFilterUid( callingUid, realCallingUid, mRequest.filterCallingUid)); aInfo = rInfo != null ? rInfo.activityInfo : null; if (aInfo != null) &#123; aInfo = mService.getActivityInfoForUser(aInfo, userId); &#125; &#125; &#125; &#125; // 用于记录Activity的数据 注2 final ActivityRecord[] outRecord = new ActivityRecord[1]; // 调用下面startActivity()方法 int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason, allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent); /** * 省略代码 */ return res; &#125;&#125;private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup, PendingIntentRecord originatingPendingIntent) &#123; if (TextUtils.isEmpty(reason)) &#123; throw new IllegalArgumentException("Need to specify a reason."); &#125; mLastStartReason = reason; mLastStartActivityTimeMs = System.currentTimeMillis(); mLastStartActivityRecord[0] = null; // 继续向下调用startActivity() mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, inTask, allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent); if (outActivity != null) &#123; // mLastStartActivityRecord[0] is set in the call to startActivity above. outActivity[0] = mLastStartActivityRecord[0]; &#125; return getExternalResult(mLastStartActivityResult);&#125;private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup, PendingIntentRecord originatingPendingIntent) &#123; int err = ActivityManager.START_SUCCESS; // Pull the optional Ephemeral Installer-only bundle out of the options early. final Bundle verificationBundle = options != null ? options.popAppVerificationBundle() : null; // 因为这个方法太长省略中间各种校验代码，简单说下都有哪些校验 // 1.caller校验防止caller被系统kill // 2.launchFlags校验，是否Intent.FLAG_ACTIVITY_FORWARD_RESULT 注3 // 3.判断是否匹配到Intent的目标 // 4.校验caller是否有权限启动目标Activity // 返回调用startActivity()方法的结果 return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, outActivity);&#125;private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; int result = START_CANCELED; try &#123; // 调用WindowManagerService推迟Surface绘制 mService.mWindowManager.deferSurfaceLayout(); // 继续向下调用启动Activity result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); &#125; finally &#123; // If we are not able to proceed, disassociate the activity from the task. Leaving an // activity in an incomplete state can lead to issues, such as performing operations // without a window container. // 获取Activity任务栈 final ActivityStack stack = mStartActivity.getStack(); // 判断Activity是否启动成功和任务栈是否为空 if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != null) &#123; // 将未启动成功不完整的Activity从栈清除 stack.finishActivityLocked(mStartActivity, RESULT_CANCELED, null /* intentResultData */, "startActivity", true /* oomAdj */); &#125; // 用WindowManagerService继续Surface绘制 mService.mWindowManager.continueSurfaceLayout(); &#125; postStartActivityProcessing(r, result, mTargetStack); return result;&#125;/*** 关于Activit启动模式和栈的一些操作有待以后详细分析*/private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; // 初始化环境和lunchModeFlags setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); // 处理Activity启动模式 computeLaunchingTaskFlags(); computeSourceStack(); mIntent.setFlags(mLaunchFlags); // 复用activity逻辑 ActivityRecord reusedActivity = getReusableIntentActivity(); int preferredWindowingMode = WINDOWING_MODE_UNDEFINED; int preferredLaunchDisplayId = DEFAULT_DISPLAY; if (mOptions != null) &#123; preferredWindowingMode = mOptions.getLaunchWindowingMode(); preferredLaunchDisplayId = mOptions.getLaunchDisplayId(); &#125; // windowing mode and preferred launch display values from &#123;@link LaunchParams&#125; take // priority over those specified in &#123;@link ActivityOptions&#125;. if (!mLaunchParams.isEmpty()) &#123; if (mLaunchParams.hasPreferredDisplay()) &#123; preferredLaunchDisplayId = mLaunchParams.mPreferredDisplayId; &#125; if (mLaunchParams.hasWindowingMode()) &#123; preferredWindowingMode = mLaunchParams.mWindowingMode; &#125; &#125; if (reusedActivity != null) &#123; // When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused but // still needs to be a lock task mode violation since the task gets cleared out and // the device would otherwise leave the locked task. if (mService.getLockTaskController().isLockTaskModeViolation(reusedActivity.getTask(), (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123; Slog.e(TAG, "startActivityUnchecked: Attempt to violate Lock Task Mode"); return START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; // True if we are clearing top and resetting of a standard (default) launch mode // (&#123;@code LAUNCH_MULTIPLE&#125;) activity. The existing activity will be finished. final boolean clearTopAndResetStandardLaunchMode = (mLaunchFlags &amp; (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)) == (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) &amp;&amp; mLaunchMode == LAUNCH_MULTIPLE; // If mStartActivity does not have a task associated with it, associate it with the // reused activity's task. Do not do so if we're clearing top and resetting for a // standard launchMode activity. if (mStartActivity.getTask() == null &amp;&amp; !clearTopAndResetStandardLaunchMode) &#123; mStartActivity.setTask(reusedActivity.getTask()); &#125; if (reusedActivity.getTask().intent == null) &#123; // This task was started because of movement of the activity based on affinity... // Now that we are actually launching it, we can assign the base intent. reusedActivity.getTask().setIntent(mStartActivity); &#125; // This code path leads to delivering a new intent, we want to make sure we schedule it // as the first operation, in case the activity will be resumed as a result of later // operations. if ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0 || isDocumentLaunchesIntoExisting(mLaunchFlags) || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123; final TaskRecord task = reusedActivity.getTask(); // In this situation we want to remove all activities from the task up to the one // being started. In most cases this means we are resetting the task to its initial // state. final ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity, mLaunchFlags); // The above code can remove &#123;@code reusedActivity&#125; from the task, leading to the // the &#123;@code ActivityRecord&#125; removing its reference to the &#123;@code TaskRecord&#125;. The // task reference is needed in the call below to // &#123;@link setTargetStackAndMoveToFrontIfNeeded&#125;. if (reusedActivity.getTask() == null) &#123; reusedActivity.setTask(task); &#125; if (top != null) &#123; if (top.frontOfTask) &#123; // Activity aliases may mean we use different intents for the top activity, // so make sure the task now has the identity of the new intent. top.getTask().setIntent(mStartActivity); &#125; deliverNewIntent(top); &#125; &#125; mSupervisor.sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, reusedActivity); reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity); final ActivityRecord outResult = outActivity != null &amp;&amp; outActivity.length &gt; 0 ? outActivity[0] : null; // When there is a reused activity and the current result is a trampoline activity, // set the reused activity as the result. if (outResult != null &amp;&amp; (outResult.finishing || outResult.noDisplay)) &#123; outActivity[0] = reusedActivity; &#125; if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) &#123; // We don't need to start a new activity, and the client said not to do anything // if that is the case, so this is it! And for paranoia, make sure we have // correctly resumed the top activity. resumeTargetStackIfNeeded(); return START_RETURN_INTENT_TO_CALLER; &#125; if (reusedActivity != null) &#123; setTaskFromIntentActivity(reusedActivity); if (!mAddingToTask &amp;&amp; mReuseTask == null) &#123; // We didn't do anything... but it was needed (a.k.a., client don't use that // intent!) And for paranoia, make sure we have correctly resumed the top activity. resumeTargetStackIfNeeded(); if (outActivity != null &amp;&amp; outActivity.length &gt; 0) &#123; outActivity[0] = reusedActivity; &#125; return mMovedToFront ? START_TASK_TO_FRONT : START_DELIVERED_TO_TOP; &#125; &#125; &#125; if (mStartActivity.packageName == null) &#123; final ActivityStack sourceStack = mStartActivity.resultTo != null ? mStartActivity.resultTo.getStack() : null; if (sourceStack != null) &#123; sourceStack.sendActivityResultLocked(-1 /* callingUid */, mStartActivity.resultTo, mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED, null /* data */); &#125; ActivityOptions.abort(mOptions); return START_CLASS_NOT_FOUND; &#125; // If the activity being launched is the same as the one currently at the top, then // we need to check if it should only be launched once. final ActivityStack topStack = mSupervisor.mFocusedStack; final ActivityRecord topFocused = topStack.getTopActivity(); final ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop); final boolean dontStart = top != null &amp;&amp; mStartActivity.resultTo == null &amp;&amp; top.realActivity.equals(mStartActivity.realActivity) &amp;&amp; top.userId == mStartActivity.userId &amp;&amp; top.app != null &amp;&amp; top.app.thread != null &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0 || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK)); // singleTop 或者singleInstance的处理 if (dontStart) &#123; // For paranoia, make sure we have correctly resumed the top activity. topStack.mLastPausedActivity = null; if (mDoResume) &#123; mSupervisor.resumeFocusedStackTopActivityLocked(); &#125; ActivityOptions.abort(mOptions); if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) &#123; // We don't need to start a new activity, and the client said not to do // anything if that is the case, so this is it! return START_RETURN_INTENT_TO_CALLER; &#125; deliverNewIntent(top); // Don't use mStartActivity.task to show the toast. We're not starting a new activity // but reusing 'top'. Fields in mStartActivity may not be fully initialized. mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredWindowingMode, preferredLaunchDisplayId, topStack); return START_DELIVERED_TO_TOP; &#125; boolean newTask = false; final TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null) ? mSourceRecord.getTask() : null; // Should this be considered a new task? // 设置对应task并带到前台 int result = START_SUCCESS; if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; result = setTaskFromReuseOrCreateNewTask(taskToAffiliate, topStack); &#125; else if (mSourceRecord != null) &#123; result = setTaskFromSourceRecord(); &#125; else if (mInTask != null) &#123; result = setTaskFromInTask(); &#125; else &#123; // This not being started from an existing activity, and not part of a new task... // just put it in the top task, though these days this case should never happen. setTaskToCurrentTopOrCreateNewTask(); &#125; if (result != START_SUCCESS) &#123; return result; &#125; mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName, mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId); mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent, mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid)); if (newTask) &#123; EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, mStartActivity.userId, mStartActivity.getTask().taskId); &#125; ActivityStack.logStartActivity( EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.getTask()); mTargetStack.mLastPausedActivity = null; mSupervisor.sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, mStartActivity); // 启动Activity mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition, mOptions); // 使Activity可见 if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; // If the activity is not focusable, we can't resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don't want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mService.mWindowManager.executeAppTransition(); &#125; else &#123; // If the target stack was not previously focusable (previous top running activity // on that stack was not visible) then any prior calls to move the stack to the // will not update the focused stack. If starting the new activity now allows the // task stack to be focusable, then ensure that we now update the focused stack // accordingly. if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront("startActivityUnchecked"); &#125; mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; &#125; else if (mStartActivity != null) &#123; mSupervisor.mRecentTasks.add(mStartActivity.getTask()); &#125; mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack); mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredWindowingMode, preferredLaunchDisplayId, mTargetStack); return START_SUCCESS;&#125; 注1：ActivityMetricsLogger.java是用来监听活动启动、转换、可见性更改和窗口绘制回调，以确定应用程序启动时间和绘制延迟。为Tron、logcat、事件日志等提供数据的类。 注2： 一个ActivityRecord对应一个Activity，保存了一个Activity的所有信息;但是一个Activity可能会有多个ActivityRecord,因为Activity可以被多次启动，这个主要取决于其启动模式。 一个TaskRecord由一个或者多个ActivityRecord组成，这就是我们常说的任务栈，具有后进先出的特点。 ActivityStack则是用来管理TaskRecord的，包含了多个TaskRecord。 注3： Intent.FLAG_ACTIVITY_FORWARD_RESULT 用于activityA 跳转 activityB 跳转 activityC，activityC返回时直接回调activityA直接跳过activityB这种情况。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动流程]]></title>
    <url>%2F2019%2F06%2F27%2FActivity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Activity启动流程Activity跳转调用Activity.startActivity()方法，最终本质还是调用startActivityForResult（）方法。 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// app/Activity.java@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125;public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; // 如果mParent为空则调用 Instrumentation.execStartActivity() // mParent这个字段是当前Activity的父Activity //一般只有TabActivity中才会对其赋值 //但由于后来被Fragment取代废弃所以这个值会一直未null if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); // 调用Instrumentation.execStartActivity()返回ActivityResult // ActivityResult是Instrumentation的一个内部类，代表着Activity的启动结果数据 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; //requestCode if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; &#125; 注：源码 startActivity() 方法内部调用 startActivityForResult() 方法 requestCode 参数默认为 -1 ， 所以我们调用 startActivityForResult() 的时候如果 requestCode 参数小于0则不会回调 onActivityResult startActivityForResult() 调用 Instrumentation.execStartActivity() 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// app/Instrumentation.java@UnsupportedAppUsagepublic ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); // 获得IActivityManager对象，并调用startActivity()方法，具体看下面源码 // IActivityManager是一个AIDL接口 // 具体实现在ActivityManagerService中 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null;&#125; 123456789101112131415161718// app/ActivityManager@UnsupportedAppUsagepublic static IActivityManager getService() &#123; return IActivityManagerSingleton.get();&#125;@UnsupportedAppUsageprivate static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; // 通过服务名去的远程ActivityManagerService实例对象 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); // 生成ActivityManagerService本地代理 final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// com/android/server/am/ActivityManagerService.java@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);&#125;public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; enforceNotIsolatedCaller("startActivity"); // 验证用户权限和多用户管理有关 userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), "startActivityAsUser"); // TODO: Switch to user app stacks here. // mActivityStartController是ActivityStartController类的实例 // 在ActivityManagerService初始化时一起被初始化，用来控制ActivityStarter // ActivityStarter是真正负责启动Activity以及stack等操作的类 // ActivityStartController只是为了ActivityManagerService调用ActivityStarter的中间类 return mActivityStartController.obtainStarter(intent, "startActivityAsUser") .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute();&#125; 12345678910// com/android/server/am/ActivityStartController.java/** * @return A starter to configure and execute starting an activity. It is valid until after * &#123;@link ActivityStarter#execute&#125; is invoked. At that point, the starter should be * considered invalid and no longer modified or used. */ActivityStarter obtainStarter(Intent intent, String reason) &#123; // 获取ActivityStarter对象 return mFactory.obtain().setIntent(intent).setReason(reason);&#125; 注：这里的 mFactory 是 ActivityStarter 内部定义的接口 Factory ， ActivityStarter 的内部类 DefaultFactory 为他的具体实现 setController(ActivityStartController controller) 方法得到 ActivityStartController 对象， obtain() 返回 ActivityStarter 对象，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// com/android/server/am/ActivityStarter.java/** * Default implementation of &#123;@link StarterFactory&#125;. */static class DefaultFactory implements Factory &#123; /** * The maximum count of starters that should be active at one time: * 1. last ran starter (for logging and post activity processing) * 2. current running starter * 3. starter from re-entry in (2) */ private final int MAX_STARTER_COUNT = 3; private ActivityStartController mController; private ActivityManagerService mService; private ActivityStackSupervisor mSupervisor; private ActivityStartInterceptor mInterceptor; // ActivityStarter的对象池 private SynchronizedPool&lt;ActivityStarter&gt; mStarterPool = new SynchronizedPool&lt;&gt;(MAX_STARTER_COUNT); DefaultFactory(ActivityManagerService service, ActivityStackSupervisor supervisor, ActivityStartInterceptor interceptor) &#123; mService = service; mSupervisor = supervisor; mInterceptor = interceptor; &#125; @Override public void setController(ActivityStartController controller) &#123; mController = controller; &#125; @Override public ActivityStarter obtain() &#123; ActivityStarter starter = mStarterPool.acquire(); if (starter == null) &#123; starter = new ActivityStarter(mController, mService, mSupervisor, mInterceptor); &#125; return starter; &#125; @Override public void recycle(ActivityStarter starter) &#123; starter.reset(true /* clearRequest*/); mStarterPool.release(starter); &#125;&#125; 上面 ActivityManagerService 中最后调用了 ActivityStarter 的 execute() 方法，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 目录：com/android/server/am/ActivityStarter.javaActivityStarter setMayWait(int userId) &#123; mRequest.mayWait = true; mRequest.userId = userId; return this;&#125;/** * Starts an activity based on the request parameters provided earlier. * @return The starter result. */int execute() &#123; try &#123; // TODO(b/64750076): Look into passing request directly to these methods to allow // for transactional diffs and preprocessing. if (mRequest.mayWait) &#123; // 因为在ActivityManagerService中调用了setMayWait()方法所以mayWait为true return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent); &#125; else &#123; return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent); &#125; &#125; finally &#123; onExecutionComplete(); &#125;&#125; 可以看到因为在 ActivityManagerService 中中调用了 setMayWait() ，所以 mayWait 值为 true ，下面会调用 startActivityMayWait 方法，因为这个方法涉及的东西有些多所以另起一篇看下。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-事件分发]]></title>
    <url>%2F2019%2F06%2F26%2FAndroid-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Android-事件分发一、基础认识 定义 当用户触摸屏幕时（View 或 ViewGroup派生的控件），将产生点击事件（Touch事件） Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象 事件类型 事件类型 具体动作 MotionEvent.ACTION_DOWN 按下View（所有事件的开始） MotionEvent.ACTION_UP 抬起View（与DOWN对应） MotionEvent.ACTION_MOVE 滑动View MotionEvent.ACTION_CANCEL 结束事件（非人为原因） 事件列 从手指接触屏幕 至 手指离开屏幕，这个过程产生的一系列事件 注：一般情况下，事件列都是以DOWN事件开始、UP事件结束，中间有无数的MOVE事件，如下图： 事件分发的顺序 即 事件传递的顺序：Activity -&gt; ViewGroup -&gt; View 事件分发过程由哪些方法协作完成 dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent() 二、Activity的事件分发当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 源码分析：Activity.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 一般事件列开始都是DOWN事件 = 按下事件，故此处基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); // -&gt;&gt;分析1 &#125; // -&gt;&gt;分析2 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; // 若getWindow().superDispatchTouchEvent(ev)的返回true // 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 &amp; 事件传递过程结束 // 否则：继续往下调用Activity.onTouchEvent &#125; // -&gt;&gt;分析4 return onTouchEvent(ev); &#125;/** * 分析1：onUserInteraction() * 作用：实现屏保功能 * 注： * a. 该方法为空方法 * b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 */ public void onUserInteraction() &#123; &#125; // 回到最初的调用原处/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow() = 获取Window类的对象 * b. Window类是抽象类，其唯一实现类 = PhoneWindow类；即此处的Window类对象 = PhoneWindow类对象 * c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // mDecor = 顶层View（DecorView）的实例对象 // -&gt;&gt; 分析3 &#125;/** * 分析3：mDecor.superDispatchTouchEvent(event) * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); // 调用父类的方法 = ViewGroup的dispatchTouchEvent() // 即 将事件传递到ViewGroup去处理，详细请看ViewGroup的事件分发机制 &#125; // 回到最初的调用原处/** * 分析4：Activity.onTouchEvent（） * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean onTouchEvent(MotionEvent event) &#123; // 当一个点击事件未被Activity下任何一个View接收 / 处理时 // 应用场景：处理发生在Window边界外的触摸事件 // -&gt;&gt; 分析5 if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; return false; // 即 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕 &#125;/** * 分析5：mWindow.shouldCloseOnTouch(this, event) */ public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; // 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等 if (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != null) &#123; return true; &#125; return false; // 返回true：说明事件在边界外，即 消费事件 // 返回false：未消费（默认）&#125;// 回到分析4调用原处 总结当一个点击事件发生时，从Activity的事件分发开始（Activity.dispatchTouchEvent()） 方法总结 三、ViewGroup事件的分发从上面Activity事件分发机制可知，ViewGroup事件分发机制从dispatchTouchEvent()开始源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 源码分析：ViewGroup.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... // 仅贴出关键代码 // 重点分析1：ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件 if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; // 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent（）修改 // 判断值2： !onInterceptTouchEvent(ev) = 对onInterceptTouchEvent()返回值取反 // a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部 // b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断 // c. 关于onInterceptTouchEvent() -&gt;&gt;分析1 ev.setAction(MotionEvent.ACTION_DOWN); final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; // 重点分析2 // 通过for循环，遍历了当前ViewGroup下的所有子View for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); // 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View // 若是，则进入条件判断内部 if (frame.contains(scrolledXInt, scrolledYInt)) &#123; final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; // 条件判断的内部调用了该View的dispatchTouchEvent() // 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制） if (child.dispatchTouchEvent(ev)) &#123; mMotionTarget = child; return true; // 调用子View的dispatchTouchEvent后是有返回值的 // 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立 // 于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出 // 即把ViewGroup的点击事件拦截掉 &#125; &#125; &#125; &#125; &#125; &#125; boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; final View target = mMotionTarget; // 重点分析3 // 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true） if (target == null) &#123; ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; &#125; return super.dispatchTouchEvent(ev); // 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent() // 因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（）） // 此处需与上面区别：子View的dispatchTouchEvent（） &#125; ... &#125;/** * 分析1：ViewGroup.onInterceptTouchEvent() * 作用：是否拦截事件 * 说明： * a. 返回true = 拦截，即事件停止往下传递（需手动设置，即复写onInterceptTouchEvent（），从而让其返回true） * b. 返回false = 不拦截（默认） */ public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; // 回到调用原处 总结 结论：Android事件分发总是先传递到ViewGroup、再传递到View 过程：当点击了某个控件时 核心方法总结 四、View事件的分发从上面ViewGroup事件分发机制知道，View事件分发机制从dispatchTouchEvent()开始源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 源码分析：View.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event); &#125; // 说明：只有以下3个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent() // 1. mOnTouchListener != null // 2. (mViewFlags &amp; ENABLED_MASK) == ENABLED // 3. mOnTouchListener.onTouch(this, event) // 下面对这3个条件逐个分析/** * 条件1：mOnTouchListener != null * 说明：mOnTouchListener变量在View.setOnTouchListener（）方法里赋值 */ public void setOnTouchListener(OnTouchListener l) &#123; mOnTouchListener = l; // 即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空） &#125; /** * 条件2：(mViewFlags &amp; ENABLED_MASK) == ENABLED * 说明： * a. 该条件是判断当前点击的控件是否enable * b. 由于很多View默认enable，故该条件恒定为true *//** * 条件3：mOnTouchListener.onTouch(this, event) * 说明：即 回调控件注册Touch事件时的onTouch（）；需手动复写设置，具体如下（以按钮Button为例） */ button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; return false; &#125; &#125;); // 若在onTouch（）返回true，就会让上述三个条件全部成立，从而使得View.dispatchTouchEvent（）直接返回true，事件分发结束 // 若在onTouch（）返回false，就会使得上述三个条件不全部成立，从而使得View.dispatchTouchEvent（）中跳出If，执行onTouchEvent(event) 接下来，我们继续看：onTouchEvent(event)的源码分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * 源码分析：View.onTouchEvent（） */ public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; // 若该控件可点击，则进入switch判断中 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; // a. 若当前的事件 = 抬起View（主要分析） case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; ...// 经过种种判断，此处省略 // 执行performClick() -&gt;&gt;分析1 performClick(); break; // b. 若当前的事件 = 按下View case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; // c. 若当前的事件 = 结束事件（非人为原因） case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; // d. 若当前的事件 = 滑动View case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; break; &#125; // 若该控件可点击，就一定返回true return true; &#125; // 若该控件不可点击，就一定返回false return false; &#125;/** * 分析1：performClick（） */ public boolean performClick() &#123; if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; // 只要我们通过setOnClickListener（）为控件View注册1个点击事件 // 那么就会给mOnClickListener变量赋值（即不为空） // 则会往下回调onClick（） &amp; performClick（）返回true &#125; return false; &#125; 总结 每当控件被点击时： 注：onTouch（）的执行 先于 onClick（） 核心方法总结]]></content>
      <tags>
        <tag>Androd</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-HashMap]]></title>
    <url>%2F2019%2F06%2F25%2FJava%E9%9B%86%E5%90%88-HashMap%2F</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>集合</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-LinkedList]]></title>
    <url>%2F2019%2F06%2F19%2FJava%E9%9B%86%E5%90%88-LinkedList%2F</url>
    <content type="text"><![CDATA[一、概述以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。 按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add()，addFirst()，removeLast()或用iterator()上的remove()能省掉指针的移动。 LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。 1234LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();list.add("语文: 1");list.add("数学: 2");list.add("英语: 3"); 二、set和get函数1234567891011public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; 这两个函数都调用了node函数，该函数会以O(n/2)的性能去获取一个节点，具体实现如下所示： 1234567891011121314Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 就是判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。]]></content>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>集合</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合-ArrayList]]></title>
    <url>%2F2019%2F06%2F16%2FJava%E9%9B%86%E5%90%88-ArrayList%2F</url>
    <content type="text"><![CDATA[一、概述以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。 直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。 ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。 12345ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add("语文: 99");list.add("数学: 98");list.add("英语: 100");list.remove(0); 在执行这四条语句时，是这么变化的： 二、add函数当我们在ArrayList中增加元素的时候，会使用add函数。他会将元素放到末尾。具体实现如下： 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 数组自动扩容 elementData[size++] = e; return true;&#125; 他的实现其实最核心的内容就是ensureCapacityInternal。这个函数就是自动扩容机制的核心。他的具体实现： 123456789101112131415161718192021222324252627private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 扩展为原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩为1.5倍还不满足需求，直接扩为需求值 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们add10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示： 三、set和get函数先做index检查，然后执行赋值或访问操作： 123456789101112public E set(int index, E element) &#123; //index检查，超出数组长度抛出IndexOutOfBoundsException异常 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 四、remove函数1234567891011121314public E remove(int index) &#123; //index检查，超出数组长度抛出IndexOutOfBoundsException异常 rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) // 把后面的往前移 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 把最后的置null elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>集合</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-集合]]></title>
    <url>%2F2019%2F06%2F12%2FJava%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[一、Java集合简介 Set：无序、不可重复 List：有序、重复的 Map：具有映射关系 Queue：队列集合实现 1. 集合与数组的区别 数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。 数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。 2. Java集合类之间的继承关系 Java的集合类主要由两个接口派生而出: Collection Map (key-value具有映射关系的集合) 二、Collection接口1. 简介Collection接口是Set,Queue,List的父接口。1.1. 接口中定义的方法 注：重点看iterator()方法 1.2. 使用Iterator遍历集合元素Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。 Iterator接口中主要定义了2个方法： 使用迭代器遍历集合： 1234567891011121314public static void main(String[] args) &#123; //创建集合 Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i ++) &#123; collection.add(i); &#125; //获得集合的迭代器 Iterator iterator = collection.iterator(); while (iterator.hasNext()) &#123; //判断是否存在下一个元素 //取出元素并打印 System.out.println(iterator.next() + ""); &#125;&#125; 注：当使用Iterator对集合元素进行迭代时，把集合元素的值传给了迭代变量，基本数据类型传递的是值。引用类型传递的仅仅是对象的引用变量。 2. Set集合Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。 Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。3. List集合3.1. 简介List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。 List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。3.2. 接口中定义的方法 void add(int index, Object element): 在列表的指定位置插入指定元素（可选操作）。 boolean addAll(int index, Collection&lt;? extends E&gt; c) : 将集合c 中的所有元素都插入到列表中的指定位置index处。 Object get(index): 返回列表中指定位置的元素。 int indexOf(Object o): 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 int lastIndexOf(Object o): 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 Object remove(int index): 移除列表中指定位置的元素。 Object set(int index, Object element): 用指定元素替换列表中指定位置的元素。 List subList(int fromIndex, int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集。 Object[] toArray(): 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 void replaceAll(UnaryOperator operator): 根据operator指定的计算规则重新设置List集合的所有元素。 void sort(Comparator c): 根据Comparator参数对List集合的元素排序。 注：replaceAll和sort为Java8 新增方法： 4. Queue集合4.1. 简介Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。4.2. 接口中定义的方法 三、Map集合1. 简介Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。 如下图所描述，key和value之间存在单向一对一关系，即通过指定的key,总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value。 2. Map集合与Set集合、List集合的关系 与Set集合的关系 如果 把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用户返回Map里所有key组成的Set集合。 与List集合的关系 如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。 3. 接口中定义的方法 Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法：]]></content>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>集合</tag>
        <tag>开发</tag>
      </tags>
  </entry>
</search>
