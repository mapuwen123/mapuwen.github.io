<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Marvin&#39;s</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Marvin&#39;s</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Marvin&#39;s"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        <article id="post-Java集合-LinkedList" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/06/19/Java集合-LinkedList/">Java集合-LinkedList</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/06/19/Java集合-LinkedList/" class="article-date">
  <time datetime="2019-06-19T05:53:38.000Z" itemprop="datePublished">2019-06-19</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/19/Java集合-LinkedList/" data-id="cjx2y202e0005aqs689ondjl7" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合/">集合</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-Java集合-ArrayList" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/06/16/Java集合-ArrayList/">Java集合-ArrayList</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/06/16/Java集合-ArrayList/" class="article-date">
  <time datetime="2019-06-15T16:41:47.000Z" itemprop="datePublished">2019-06-16</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><pre><code>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。

按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。

直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。

ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"语文: 99"</span>);</span><br><span class="line">list.add(<span class="string">"数学: 98"</span>);</span><br><span class="line">list.add(<span class="string">"英语: 100"</span>);</span><br><span class="line">list.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在执行这四条语句时，是这么变化的：</p>
<p><img src="/img/20190616-0/20190616-0-0.png" alt="Arraylist Img"></p>
<h2 id="二、add函数"><a href="#二、add函数" class="headerlink" title="二、add函数"></a>二、add函数</h2><p>当我们在ArrayList中增加元素的时候，会使用<code>add</code>函数。他会将元素放到末尾。具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 数组自动扩容</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的实现其实最核心的内容就是<code>ensureCapacityInternal</code>。这个函数就是<strong>自动扩容机制的核心</strong>。他的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩展为原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩为1.5倍还不满足需求，直接扩为需求值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们<code>add</code>10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示：</p>
<p><img src="/img/20190616-0/20190616-0-1.png" alt="Arraylist add Img"></p>
<h2 id="三、set和get函数"><a href="#三、set和get函数" class="headerlink" title="三、set和get函数"></a>三、set和get函数</h2><p>先做index检查，然后执行赋值或访问操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//index检查，超出数组长度抛出IndexOutOfBoundsException异常</span></span><br><span class="line">    rangeCheck(index); </span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、remove函数"><a href="#四、remove函数" class="headerlink" title="四、remove函数"></a>四、remove函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//index检查，超出数组长度抛出IndexOutOfBoundsException异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 把后面的往前移</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 把最后的置null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/16/Java集合-ArrayList/" data-id="cjx2y202a0002aqs6ew350vq6" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合/">集合</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-Java基础-集合" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/06/12/Java基础-集合/">Java基础-集合</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/06/12/Java基础-集合/" class="article-date">
  <time datetime="2019-06-11T21:13:03.000Z" itemprop="datePublished">2019-06-12</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      
  <div class="article-gallery">
    <div class="article-gallery-photos">
      
        
          <a class="article-gallery-img" href="/2019/06/12/Java基础-集合/" rel="gallery_cjx2y20240000aqs6kd08op3t">
            <img src="/img/20190612-0/3985563-e7febf364d8d8235.png" itemprop="image">
          </a>
        
      
    </div>
  </div>


      
        <h2 id="一、Java集合简介"><a href="#一、Java集合简介" class="headerlink" title="一、Java集合简介"></a>一、Java集合简介</h2><ul>
<li><p>Set：无序、不可重复</p>
</li>
<li><p>List：有序、重复的</p>
</li>
<li><p>Map：具有映射关系</p>
</li>
<li><p>Queue：队列集合实现</p>
</li>
</ul>
<h3 id="1-集合与数组的区别"><a href="#1-集合与数组的区别" class="headerlink" title="1. 集合与数组的区别"></a>1. 集合与数组的区别</h3><ul>
<li><p>数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。</p>
</li>
<li><p>数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。</p>
</li>
</ul>
<h3 id="2-Java集合类之间的继承关系"><a href="#2-Java集合类之间的继承关系" class="headerlink" title="2. Java集合类之间的继承关系"></a>2. Java集合类之间的继承关系</h3><ul>
<li><p>Java的集合类主要由两个接口派生而出:</p>
<ul>
<li><p>Collection</p>
<p><img src="/img/20190612-0/3985563-e7febf364d8d8235-1.png" alt="Collection Img"></p>
</li>
<li><p>Map (key-value具有映射关系的集合)</p>
<p><img src="/img/20190612-0/3985563-06052107849a7603-2.png" alt="Map Img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="二、Collection接口"><a href="#二、Collection接口" class="headerlink" title="二、Collection接口"></a>二、Collection接口</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><pre><code>Collection接口是Set,Queue,List的父接口。</code></pre><h4 id="1-1-接口中定义的方法"><a href="#1-1-接口中定义的方法" class="headerlink" title="1.1. 接口中定义的方法"></a>1.1. 接口中定义的方法</h4><p><img src="/img/20190612-0/3985563-414332ffe4733274-3.png" alt="Collection Function Img"></p>
<p><strong><em>注：重点看iterator()方法</em></strong></p>
<h4 id="1-2-使用Iterator遍历集合元素"><a href="#1-2-使用Iterator遍历集合元素" class="headerlink" title="1.2. 使用Iterator遍历集合元素"></a>1.2. 使用Iterator遍历集合元素</h4><pre><code>Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。 Iterator接口中主要定义了2个方法：</code></pre><p><img src="/img/20190612-0/3985563-63737a2d81713a47-4.png" alt="Iterator Img"></p>
<p>使用迭代器遍历集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建集合</span></span><br><span class="line">    Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        collection.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得集合的迭代器</span></span><br><span class="line">    Iterator iterator = collection.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123; <span class="comment">//判断是否存在下一个元素</span></span><br><span class="line">        <span class="comment">//取出元素并打印</span></span><br><span class="line">        System.out.println(iterator.next() + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>当使用Iterator对集合元素进行迭代时，把集合元素的值传给了迭代变量，<strong>基本数据类型</strong>传递的是<strong>值</strong>。<strong>引用类型</strong>传递的仅仅是对象的<strong>引用变量</strong>。</p>
<h3 id="2-Set集合"><a href="#2-Set集合" class="headerlink" title="2. Set集合"></a>2. Set集合</h3><pre><code>Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。

Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。</code></pre><h3 id="3-List集合"><a href="#3-List集合" class="headerlink" title="3. List集合"></a>3. List集合</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1. 简介"></a>3.1. 简介</h4><pre><code>List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。

List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。</code></pre><h4 id="3-2-接口中定义的方法"><a href="#3-2-接口中定义的方法" class="headerlink" title="3.2. 接口中定义的方法"></a>3.2. 接口中定义的方法</h4><ul>
<li><p><strong>void add(int index, Object element):</strong> 在列表的指定位置插入指定元素（可选操作）。</p>
</li>
<li><p><strong>boolean addAll(int index, Collection&lt;? extends E&gt; c) :</strong> 将集合c 中的所有元素都插入到列表中的指定位置index处。</p>
</li>
<li><p><strong>Object get(index):</strong>  返回列表中指定位置的元素。</p>
</li>
<li><p><strong>int indexOf(Object o):</strong> 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。</p>
</li>
<li><p><strong>int lastIndexOf(Object o):</strong> 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。</p>
</li>
<li><p><strong>Object remove(int index):</strong> 移除列表中指定位置的元素。</p>
</li>
<li><p><strong>Object set(int index, Object element):</strong> 用指定元素替换列表中指定位置的元素。</p>
</li>
<li><p><strong>List subList(int fromIndex, int toIndex):</strong> 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集。</p>
</li>
<li><p><strong>Object[] toArray():</strong> 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。</p>
</li>
<li><p><strong>void replaceAll(UnaryOperator operator):</strong> 根据operator指定的计算规则重新设置List集合的所有元素。</p>
</li>
<li><p><strong>void sort(Comparator c):</strong> 根据Comparator参数对List集合的元素排序。</p>
<p><strong>注：</strong>replaceAll和sort为Java8 新增方法：</p>
</li>
</ul>
<h3 id="4-Queue集合"><a href="#4-Queue集合" class="headerlink" title="4. Queue集合"></a>4. Queue集合</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1. 简介"></a>4.1. 简介</h4><pre><code>Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</code></pre><h4 id="4-2-接口中定义的方法"><a href="#4-2-接口中定义的方法" class="headerlink" title="4.2. 接口中定义的方法"></a>4.2. 接口中定义的方法</h4><p><img src="/img/20190612-0/3985563-0505554930ca982e-5.png" alt="Queue Function Img"></p>
<h2 id="三、Map集合"><a href="#三、Map集合" class="headerlink" title="三、Map集合"></a>三、Map集合</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><pre><code>Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。

如下图所描述，key和value之间存在单向一对一关系，即通过指定的key,总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value。</code></pre><p><img src="/img/20190612-0/3985563-51f6c5278df941fe-6.png" alt="Map Img"></p>
<h3 id="2-Map集合与Set集合、List集合的关系"><a href="#2-Map集合与Set集合、List集合的关系" class="headerlink" title="2. Map集合与Set集合、List集合的关系"></a>2. Map集合与Set集合、List集合的关系</h3><ul>
<li><p><strong>与Set集合的关系</strong></p>
<p>如果 把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用户返回Map里所有key组成的Set集合。</p>
</li>
<li><p><strong>与List集合的关系</strong></p>
<p>如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。</p>
</li>
</ul>
<h3 id="3-接口中定义的方法"><a href="#3-接口中定义的方法" class="headerlink" title="3. 接口中定义的方法"></a>3. 接口中定义的方法</h3><p><img src="/img/20190612-0/3985563-d2494516e1d68a6d-7.png" alt="Map Function Img"></p>
<p>Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法：</p>
<p><img src="/img/20190612-0/3985563-ecedd1880af9d40a-8.png" alt="Entry Function Img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/12/Java基础-集合/" data-id="cjx2y20240000aqs6kd08op3t" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合/">集合</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
  </article>
  
  
</section>
</div>

  <footer class="footer">
  
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 Marvin&#39;s</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Marvin&#39;s"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
      <li class="nav-item">
          <div class="totop" id="totop">
    <i class="fe fe-rocket"></i>
</div>
      </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>